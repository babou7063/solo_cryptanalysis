from elliptic_curve import Point, EllipticCurve
from utils import modinv
import random
import matplotlib.pyplot as plt
import time

def partition(point, r):
    """
    Partition the point in one of r zones based on its x-coordinate.
    This defines which update rule will be used in the walk.
    
    :param point: the point to partition
    :param r: the number of zones
    :return: the zone number of the point (in the range [0, r-1])
    """
    if not point.at_infinity:
        return point.x % r
    else :
        return 0


def update(W, a, b, P, Q, order, r=3):
    """
    Update the current point W and coefficients a, b based on the partition zone.
    Returns new point W', and updated a, b coefficients modulo order.
    
    :param W: the current point in the walk
    :param a: current coefficient a in the linear combination of P
    :param b: current coefficient b in the linear combination of Q
    :param P: a fixed point on the elliptic curve
    :param Q: another fixed point on the elliptic curve
    :param order: the order of the group generated by P
    :param r: the number of partitions in the walk (default: 3)
    :return: the updated point and coefficients (W_new, a_new, b_new)
    """

    zone = partition(W, r)
    
    if zone == 0:
        # Add P
        W_new = W + P
        a_new = (a + 1) % order
        b_new = b
    elif zone == 1:
        # Add Q
        W_new = W + Q
        a_new = a
        b_new = (b + 1) % order
    else:
        # Double the point
        W_new = W + W
        a_new = (2 * a) % order
        b_new = (2 * b) % order

    return W_new, a_new, b_new


def pollard_rho(P, Q, order, curve, r=3):
    """
    Find a scalar k such that Q = kP using the Pollard's rho algorithm.

    :param P: a point on the curve
    :param Q: a point on the curve, such that Q = kP
    :param order: the order of P
    :param curve: the elliptic curve
    :param r: the number of partitions in the walk (default: 3)
    :return: the scalar k such that Q = kP
    """
    
    a = random.randint(1, order - 1)
    b = random.randint(1, order - 1)
    W = curve.scalar_mul(a, P) + curve.scalar_mul(b, Q)

    # Init tortoise
    A = a
    B = b
    R = W

    # Init hare
    A2 = a
    B2 = b
    R2 = W
    
    # Separate traces for tortoise and hare
    tortoise_trace = [(R.x, R.y)]
    hare_trace = [(R2.x, R2.y)]

    step = 0
    while True:
        step += 1
        # Tortoise: 1 step
        R, A, B = update(R, A, B, P, Q, order, r)
        tortoise_trace.append((R.x, R.y))
        
        # Hare: 2 steps
        for _ in range(2):
            R2, A2, B2 = update(R2, A2, B2, P, Q, order, r)
        hare_trace.append((R2.x, R2.y))

        # Collision detection
        if R == R2:
            if (B - B2) % order == 0:
                raise Exception("Failure: b - b' ≡ 0 mod order, try again with different start")
            k = ((A - A2) * modinv(B2 - B, order)) % order
            return k, tortoise_trace, hare_trace, step

def animated_visualization(P, Q, order, curve, r=3):
    """
    Create an animated step-by-step visualization
    """
    try:
        k_found, tortoise_trace, hare_trace, total_steps = pollard_rho(P, Q, order, curve, r)
        print(f"Found k = {k_found} in {total_steps} steps")
        print("Tortoise trace:", tortoise_trace)
        print("Hare trace:", hare_trace)
        
        fig, ax = plt.subplots(figsize=(8, 5))
        ax.set_title("Pollard's Rho Algorithm - Animated Visualization")
        ax.set_xlabel("X")
        ax.set_ylabel("Y") 
        ax.grid(True)
        
        # Filter valid points
        valid_tortoise = [(x, y) for x, y in tortoise_trace if x is not None and y is not None]
        valid_hare = [(x, y) for x, y in hare_trace if x is not None and y is not None]
        
        max_steps = min(len(valid_tortoise), len(valid_hare))
        
        for step in range(max_steps):
            if step > 0:
                # Clear previous step (keep accumulating)
                pass
            
            # Plot tortoise path up to current step
            if step < len(valid_tortoise):
                tortoise_x = [valid_tortoise[i][0] for i in range(step + 1)]
                tortoise_y = [valid_tortoise[i][1] for i in range(step + 1)]
                ax.plot(tortoise_x, tortoise_y, 'b-', alpha=0.6, linewidth=2, label='Tortoise' if step == 0 else "")
                ax.scatter(tortoise_x[-1], tortoise_y[-1], color='blue', s=80, zorder=5)
                
                # Add arrows for tortoise
                if len(tortoise_x) > 1:
                    ax.annotate('', xy=(tortoise_x[-1], tortoise_y[-1]), xytext=(tortoise_x[-2], tortoise_y[-2]), arrowprops=dict(arrowstyle='->', color='blue', lw=2))
        
        # Plot hare path up to current step
            if step < len(valid_hare):
                hare_x = [valid_hare[i][0] for i in range(step + 1)]
                hare_y = [valid_hare[i][1] for i in range(step + 1)]
                ax.plot(hare_x, hare_y, 'r--', alpha=0.6, linewidth=2, label='Hare' if step == 0 else "")
                ax.scatter(hare_x[-1], hare_y[-1], color='red', s=80, marker='^', zorder=5)
                
                # Add arrows for hare
                if len(hare_x) > 1:
                    ax.annotate('', xy=(hare_x[-1], hare_y[-1]), xytext=(hare_x[-2], hare_y[-2]), arrowprops=dict(arrowstyle='->', color='red', lw=2))

            if step == 0:
                ax.legend()
            
            ax.set_title(f"Pollard's Rho Algorithm - Step {step + 1}/{max_steps}")
            plt.pause(0.8)
        
        # Highlight collision point
        if valid_tortoise and valid_hare:
            collision_x, collision_y = valid_tortoise[-1]
            ax.scatter(collision_x, collision_y, color='gold', s=200, marker='*', edgecolor='black', linewidth=2, zorder=10, label='Collision!')
            ax.legend()
            ax.set_title(f"Collision found! k = {k_found}")

        plt.show()
        return k_found
        
    except Exception as e:
        print(f"Algorithm failed: {e}")
        return None

# Test
# Courbe : y^2 = x^3 + 2x + 3 mod 97
p = 97
a = 2
b = 3
curve = EllipticCurve(a, b, p)

# Point P sur la courbe (ordre order connu)
P = Point(3, 6, curve)


# TODO : fct pour trouver ordre de P
order = curve.find_order(P)  # ordre connu de P (exemple réduit pour test rapide)
print("Order of P:", order)

# Secret à retrouver
k_secret = 7
Q = curve.scalar_mul(k_secret, P)

#k_found_animated = animated_visualization(P, Q, order, curve)