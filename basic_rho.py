from elliptic_curve import Point, EllipticCurve
from utils import modinv
import random

def partition(point, r):
    """
    Partition the point in one of r zones based on its x-coordinate.
    This defines which update rule will be used in the walk.
    
    :param point: the point to partition
    :param r: the number of zones
    :return: the zone number of the point (in the range [0, r-1])
    """
    if not point.at_infinity:
        return point.x % r
    else :
        return 0


def update(W, a, b, P, Q, order, r=3):
    """
    Update the current point W and coefficients a, b based on the partition zone.
    Returns new point W', and updated a, b coefficients modulo order.
    
    :param W: the current point in the walk
    :param a: current coefficient a in the linear combination of P
    :param b: current coefficient b in the linear combination of Q
    :param P: a fixed point on the elliptic curve
    :param Q: another fixed point on the elliptic curve
    :param order: the order of the group generated by P
    :param r: the number of partitions in the walk (default: 3)
    :return: the updated point and coefficients (W_new, a_new, b_new)
    """

    zone = partition(W, r)
    
    if zone == 0:
        # Add P
        W_new = W + P
        a_new = (a + 1) % order
        b_new = b
    elif zone == 1:
        # Add Q
        W_new = W + Q
        a_new = a
        b_new = (b + 1) % order
    else:
        # Double the point
        W_new = W + W
        a_new = (2 * a) % order
        b_new = (2 * b) % order

    return W_new, a_new, b_new


def pollard_rho(P, Q, order, curve, r=3):
    """
    Find a scalar k such that Q = kP using the Pollard's rho algorithm.

    :param P: a point on the curve
    :param Q: a point on the curve, such that Q = kP
    :param order: the order of P
    :param curve: the elliptic curve
    :param r: the number of partitions in the walk (default: 3)
    :return: the scalar k such that Q = kP
    """
    
    a = random.randint(1, order - 1)
    b = random.randint(1, order - 1)
    W = curve.scalar_mul(a, P) + curve.scalar_mul(b, Q)

    # Init tortoise
    A = a
    B = b
    R = W

    # Init hare
    A2 = a
    B2 = b
    R2 = W

    while True:
        # Tortoise: 1 step
        R, A, B = update(R, A, B, P, Q, order, r)
        
        # Hare: 2 steps
        for _ in range(2):
            R2, A2, B2 = update(R2, A2, B2, P, Q, order, r)

        # Collision detection
        if R == R2:
            if (B - B2) % order == 0:
                raise Exception("Failure: b - b' ≡ 0 mod order, try again with different start")
            k = ((A - A2) * modinv(B2 - B, order)) % order
            return k



# Test
# Courbe : y^2 = x^3 + 2x + 3 mod 97
p = 97
a = 2
b = 3
curve = EllipticCurve(a, b, p)

# Point P sur la courbe (ordre order connu)
P = Point(3, 6, curve)

# TODO : fct pour trouver ordre de P
order = curve.find_order(P)  # ordre connu de P (exemple réduit pour test rapide)
print("Order of P:", order)

# Secret à retrouver
k_secret = 4
Q = curve.scalar_mul(k_secret, P)

print(f"Trying to find k such that Q = kP")
print(f"P = {P}")
print(f"Q = {Q}")

# Exécution de l'algorithme rho
k_found = pollard_rho(P, Q, order, curve)

print(f"Found k = {k_found}")
assert k_found == k_secret % order