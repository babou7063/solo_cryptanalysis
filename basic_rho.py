from elliptic_curve import Point, EllipticCurve
from utils import modinv
import random
import matplotlib.pyplot as plt
import time

def partition(point, r):
    """
    Partition the point in one of r zones based on its x-coordinate.
    This defines which update rule will be used in the walk.
    
    :param point: the point to partition
    :param r: the number of zones
    :return: the zone number of the point (in the range [0, r-1])
    """
    if not point.at_infinity:
        return point.x % r
    else :
        return 0


def update(W, a, b, P, Q, order, r=3):
    """
    Update the current point W and coefficients a, b based on the partition zone.
    Returns new point W', and updated a, b coefficients modulo order.
    
    :param W: the current point in the walk
    :param a: current coefficient a in the linear combination of P
    :param b: current coefficient b in the linear combination of Q
    :param P: a fixed point on the elliptic curve
    :param Q: another fixed point on the elliptic curve
    :param order: the order of the group generated by P
    :param r: the number of partitions in the walk (default: 3)
    :return: the updated point and coefficients (W_new, a_new, b_new)
    """

    zone = partition(W, r)
    
    if zone == 0:
        # Add P
        W_new = W + P
        a_new = (a + 1) % order
        b_new = b
    elif zone == 1:
        # Add Q
        W_new = W + Q
        a_new = a
        b_new = (b + 1) % order
    else:
        # Double the point
        W_new = W + W
        a_new = (2 * a) % order
        b_new = (2 * b) % order

    return W_new, a_new, b_new


def pollard_rho(P, Q, order, curve, r=3):
    """
    Find a scalar k such that Q = kP using the Pollard's rho algorithm.

    :param P: a point on the curve
    :param Q: a point on the curve, such that Q = kP
    :param order: the order of P
    :param curve: the elliptic curve
    :param r: the number of partitions in the walk (default: 3)
    :return: the scalar k such that Q = kP
    """
    
    a = random.randint(1, order - 1)
    b = random.randint(1, order - 1)
    W = curve.scalar_mul(a, P) + curve.scalar_mul(b, Q)

    # Init tortoise
    A = a
    B = b
    R = W

    # Init hare
    A2 = a
    B2 = b
    R2 = W
    
    trace = [(R.x, R.y)]


    while True:
        # Tortoise: 1 step
        R, A, B = update(R, A, B, P, Q, order, r)
        trace.append((R.x, R.y))
        
        # Hare: 2 steps
        for _ in range(2):
            R2, A2, B2 = update(R2, A2, B2, P, Q, order, r)

        # Collision detection
        if R == R2:
            if (B - B2) % order == 0:
                raise Exception("Failure: b - b' ≡ 0 mod order, try again with different start")
            k = ((A - A2) * modinv(B2 - B, order)) % order
            return k, trace



# Test
# Courbe : y^2 = x^3 + 2x + 3 mod 97
p = 97
a = 2
b = 3
curve = EllipticCurve(a, b, p)

# Point P sur la courbe (ordre order connu)
P = Point(3, 6, curve)


# TODO : fct pour trouver ordre de P
order = curve.find_order(P)  # ordre connu de P (exemple réduit pour test rapide)
print("Order of P:", order)

# Secret à retrouver
k_secret = 4
Q = curve.scalar_mul(k_secret, P)

"""
print(f"Trying to find k such that Q = kP")
print(f"P = {P}")
print(f"Q = {Q}")

# Exécution de l'algorithme rho
k_found = pollard_rho(P, Q, order, curve)

print(f"Found k = {k_found}")
assert k_found == k_secret % order
"""


# Plotting
k_found, trace_points = pollard_rho(P, Q, order, curve)

fig, ax = plt.subplots(figsize=(10, 6))
ax.set_title("Visualization of the steps of Pollard’s rho algorithm")
ax.set_xlabel("X")
ax.set_ylabel("Y")
ax.grid(True)

# List of points
fig.subplots_adjust(left=0.3)
text_box = fig.add_axes([0.05, 0.1, 0.2, 0.8])
text_box.axis("off")
visited_lines = []

# Init
x_prev, y_prev = trace_points[0]
ax.scatter(x_prev, y_prev, color='red', s=40)
visited_lines.append(f"{0}: ({x_prev}, {y_prev})")
text_box.text(0, 1, "\n".join(visited_lines), fontsize=9, va='top')

# Animation
for i in range(1, len(trace_points) + 1):
    x1, y1 = trace_points[i - 1]
    x2, y2 = trace_points[i % len(trace_points)]
    
    if None in (x1, x2, y1, y2):
        visited_lines.append(f"{i%len(trace_points)}: ({x2}, {y2})")
        text_box.clear()
        text_box.axis("off")
        text_box.text(0, 1, "\n".join(visited_lines[-25:]), fontsize=9, va='top')

    if x1 is None or x2 is None or y1 is None or y2 is None:
        continue

    # points and lines
    ax.plot([x1, x2], [y1, y2], 'k-', linewidth=0.5)
    ax.scatter(x2, y2, color='blue', s=40)

    # list
    visited_lines.append(f"{i%len(trace_points)}: ({x2}, {y2})")
    text_box.clear()
    text_box.axis("off")
    text_box.text(0, 1, "\n".join(visited_lines[-25:]), fontsize=9, va='top')

    plt.pause(0.5)

plt.show()