from elliptic_curve import Point, EllipticCurve
from utils import modinv
import random
import matplotlib.pyplot as plt
import time

def partition(point, r):
    """
    Partition the point in one of r zones based on its x-coordinate.
    This defines which update rule will be used in the walk.
    
    :param point: the point to partition
    :param r: the number of zones
    :return: the zone number of the point (in the range [0, r-1])
    """
    if not point.at_infinity:
        return point.x % r
    else :
        return 0


def update(W, a, b, P, Q, order, r=3):
    """
    Update the current point W and coefficients a, b based on the partition zone.
    Returns new point W', and updated a, b coefficients modulo order.
    
    :param W: the current point in the walk
    :param a: current coefficient a in the linear combination of P
    :param b: current coefficient b in the linear combination of Q
    :param P: a fixed point on the elliptic curve
    :param Q: another fixed point on the elliptic curve
    :param order: the order of the group generated by P
    :param r: the number of partitions in the walk (default: 3)
    :return: the updated point and coefficients (W_new, a_new, b_new)
    """

    zone = partition(W, r)
    
    if zone == 0:
        # Add P
        W_new = W + P
        a_new = (a + 1) % order
        b_new = b
    elif zone == 1:
        # Add Q
        W_new = W + Q
        a_new = a
        b_new = (b + 1) % order
    else:
        # Double the point
        W_new = W + W
        a_new = (2 * a) % order
        b_new = (2 * b) % order

    return W_new, a_new, b_new


def pollard_rho(P, Q, order, curve, r=3):
    """
    Find a scalar k such that Q = kP using the Pollard's rho algorithm.

    :param P: a point on the curve
    :param Q: a point on the curve, such that Q = kP
    :param order: the order of P
    :param curve: the elliptic curve
    :param r: the number of partitions in the walk (default: 3)
    :return: the scalar k such that Q = kP, and traces for both tortoise and hare
    """
    
    a = random.randint(1, order - 1)
    b = random.randint(1, order - 1)
    W = curve.scalar_mul(a, P) + curve.scalar_mul(b, Q)

    # Init tortoise
    A = a
    B = b
    R = W

    # Init hare
    A2 = a
    B2 = b
    R2 = W
    
    # Separate traces for tortoise and hare
    tortoise_trace = [(R.x if not R.at_infinity else None, R.y if not R.at_infinity else None)]
    hare_trace = [(R2.x if not R2.at_infinity else None, R2.y if not R2.at_infinity else None)]

    step = 0
    while True:
        step += 1
        # Tortoise: 1 step
        R, A, B = update(R, A, B, P, Q, order, r)
        tortoise_trace.append((R.x if not R.at_infinity else None, R.y if not R.at_infinity else None))
        
        # Hare: 2 steps
        for _ in range(2):
            R2, A2, B2 = update(R2, A2, B2, P, Q, order, r)
        hare_trace.append((R2.x if not R2.at_infinity else None, R2.y if not R2.at_infinity else None))

        # Collision detection
        if R == R2:
            if (B - B2) % order == 0:
                raise Exception("Failure: b - b' â‰¡ 0 mod order, try again with different start")
            k = ((A - A2) * modinv(B2 - B, order)) % order
            return k, tortoise_trace, hare_trace, step


def visualize_pollard_rho(P, Q, order, curve, r=3):
    """
    Visualize the Pollard's rho algorithm step by step
    """
    try:
        k_found, tortoise_trace, hare_trace, total_steps = pollard_rho(P, Q, order, curve, r)
        print(f"Found k = {k_found} in {total_steps} steps")
        
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 8))
        
        # Left plot: Tortoise path
        ax1.set_title("Tortoise Path (1 step per iteration)")
        ax1.set_xlabel("X")
        ax1.set_ylabel("Y")
        ax1.grid(True)
        
        # Right plot: Hare path  
        ax2.set_title("Hare Path (2 steps per iteration)")
        ax2.set_xlabel("X")
        ax2.set_ylabel("Y")
        ax2.grid(True)
        
        # Plot tortoise path
        valid_tortoise = [(x, y) for x, y in tortoise_trace if x is not None and y is not None]
        if len(valid_tortoise) > 1:
            x_coords = [p[0] for p in valid_tortoise]
            y_coords = [p[1] for p in valid_tortoise]
            
            # Plot points
            ax1.scatter(x_coords, y_coords, c=range(len(x_coords)), cmap='viridis', s=50, alpha=0.7)
            
            # Plot arrows between consecutive points
            for i in range(len(valid_tortoise) - 1):
                x1, y1 = valid_tortoise[i]
                x2, y2 = valid_tortoise[i + 1]
                ax1.annotate('', xy=(x2, y2), xytext=(x1, y1),
                           arrowprops=dict(arrowstyle='->', color='blue', alpha=0.6, lw=1))
            
            # Mark start and end
            ax1.scatter(x_coords[0], y_coords[0], color='green', s=100, marker='s', label='Start')
            ax1.scatter(x_coords[-1], y_coords[-1], color='red', s=100, marker='X', label='Collision')
            ax1.legend()
        
        # Plot hare path
        valid_hare = [(x, y) for x, y in hare_trace if x is not None and y is not None]
        if len(valid_hare) > 1:
            x_coords = [p[0] for p in valid_hare]
            y_coords = [p[1] for p in valid_hare]
            
            # Plot points
            ax2.scatter(x_coords, y_coords, c=range(len(x_coords)), cmap='plasma', s=50, alpha=0.7)
            
            # Plot arrows between consecutive points
            for i in range(len(valid_hare) - 1):
                x1, y1 = valid_hare[i]
                x2, y2 = valid_hare[i + 1]
                ax2.annotate('', xy=(x2, y2), xytext=(x1, y1),
                           arrowprops=dict(arrowstyle='->', color='red', alpha=0.6, lw=1))
            
            # Mark start and end
            ax2.scatter(x_coords[0], y_coords[0], color='green', s=100, marker='s', label='Start')
            ax2.scatter(x_coords[-1], y_coords[-1], color='red', s=100, marker='X', label='Collision')
            ax2.legend()
        
        plt.tight_layout()
        plt.show()
        
        return k_found
        
    except Exception as e:
        print(f"Algorithm failed: {e}")
        return None


def animated_visualization(P, Q, order, curve, r=3):
    """
    Create an animated step-by-step visualization
    """
    try:
        k_found, tortoise_trace, hare_trace, total_steps = pollard_rho(P, Q, order, curve, r)
        print(f"Found k = {k_found} in {total_steps} steps")
        
        fig, ax = plt.subplots(figsize=(12, 8))
        ax.set_title("Pollard's Rho Algorithm - Animated Visualization")
        ax.set_xlabel("X")
        ax.set_ylabel("Y") 
        ax.grid(True)
        
        # Filter valid points
        valid_tortoise = [(x, y) for x, y in tortoise_trace if x is not None and y is not None]
        valid_hare = [(x, y) for x, y in hare_trace if x is not None and y is not None]
        
        max_steps = min(len(valid_tortoise), len(valid_hare))
        
        for step in range(max_steps):
            if step > 0:
                # Clear previous step (keep accumulating)
                pass
            
            # Plot tortoise path up to current step
            if step < len(valid_tortoise):
                tortoise_x = [valid_tortoise[i][0] for i in range(step + 1)]
                tortoise_y = [valid_tortoise[i][1] for i in range(step + 1)]
                ax.plot(tortoise_x, tortoise_y, 'b-', alpha=0.6, linewidth=2, label='Tortoise' if step == 0 else "")
                ax.scatter(tortoise_x[-1], tortoise_y[-1], color='blue', s=80, zorder=5)
                
                # Add arrows for tortoise
                if len(tortoise_x) > 1:
                    ax.annotate('', xy=(tortoise_x[-1], tortoise_y[-1]), 
                              xytext=(tortoise_x[-2], tortoise_y[-2]),
                              arrowprops=dict(arrowstyle='->', color='blue', lw=2))
            
            # Plot hare path up to current step
            if step < len(valid_hare):
                hare_x = [valid_hare[i][0] for i in range(step + 1)]
                hare_y = [valid_hare[i][1] for i in range(step + 1)]
                ax.plot(hare_x, hare_y, 'r--', alpha=0.6, linewidth=2, label='Hare' if step == 0 else "")
                ax.scatter(hare_x[-1], hare_y[-1], color='red', s=80, marker='^', zorder=5)
                
                # Add arrows for hare
                if len(hare_x) > 1:
                    ax.annotate('', xy=(hare_x[-1], hare_y[-1]), 
                              xytext=(hare_x[-2], hare_y[-2]),
                              arrowprops=dict(arrowstyle='->', color='red', lw=2))
            
            if step == 0:
                ax.legend()
            
            ax.set_title(f"Pollard's Rho Algorithm - Step {step + 1}/{max_steps}")
            plt.pause(0.8)
        
        # Highlight collision point
        if valid_tortoise and valid_hare:
            collision_x, collision_y = valid_tortoise[-1]
            ax.scatter(collision_x, collision_y, color='gold', s=200, marker='*', 
                      edgecolor='black', linewidth=2, zorder=10, label='Collision!')
            ax.legend()
            ax.set_title(f"Collision found! k = {k_found}")
        
        plt.show()
        return k_found
        
    except Exception as e:
        print(f"Algorithm failed: {e}")
        return None


# Test
# Curve: y^2 = x^3 + 2x + 3 mod 97
p = 97
a = 2
b = 3
curve = EllipticCurve(a, b, p)

# Point P on the curve
P = Point(3, 6, curve)

# Find order of P
order = curve.find_order(P)
print("Order of P:", order)

# Secret to find
k_secret = 7
Q = curve.scalar_mul(k_secret, P)

print(f"Trying to find k such that Q = kP")
print(f"P = {P}")
print(f"Q = {Q}") 
print(f"Secret k = {k_secret}")

# Run visualization
#print("\n=== Static Visualization ===")
#k_found = visualize_pollard_rho(P, Q, order, curve)

print(f"\n=== Animated Visualization ===")
k_found_animated = animated_visualization(P, Q, order, curve)

"""
if k_found:
    print(f"\nVerification: k_found = {k_found}, k_secret = {k_secret}")
    print(f"Match: {k_found == k_secret % order}")
    """